package main

import (
	"fmt"

	zfs "github.com/kelleyk/go-libzfs"
)

// TODO: move to go-libzfs
func visitSnapshots(f func(zfs.Dataset) error, d zfs.Dataset) error {
	for _, child := range d.Children {
		if child.Properties[zfs.DatasetPropType].Value == "snapshot" {
			if err := f(child); err != nil {
				return err
			}
		}
	}
	return nil
}

func oldWalkDataset(d *zfs.Dataset) {
	path, err := d.Path()
	if err != nil {
		panic(err)
	}

	isMounted, mountPath := d.IsMounted()

	fmt.Printf("%v", path)
	if isMounted {
		fmt.Printf(" [mounted: %v]", mountPath)
	}
	fmt.Printf("\n")
	for propID, prop := range d.Properties {
		propName := zfs.DatasetPropertyToName(propID)

		// zfs.DatasetPropType can be "snapshot", "filesystem", "volume"
		if propID == zfs.DatasetPropType {
			// if prop.Value == "snapshot" {
			// 	continue
			// }
		} else {
			continue
		}

		// N.B.: These are converted from the ZFS_SRC_* constants in go-libzfs's zprop_source_tostr() function.
		// Can/should we remove the string conversion?
		switch prop.Source {
		case "none":
			//   This property is read-only. Its value is generated by ZFS.
		case "local":
			//   This property value was explicitly set for this dataset by using zfs set.
		case "default":
			//   This property value was never explicitly set for this dataset or any of its ancestors. The default
			//   value for this property is being used.
		case "inherited":
			//   This property value is inherited from the parent dataset specified in dataset-name.
		case "temporary":
			//   This property value was set by using the zfs mount -o option and is only valid for the duration of the
			//   mount. For more information about temporary mount point properties, see Using Temporary Mount
			//   Properties.
		default:
		}
		fmt.Printf("  %v = %v [%v]\n", propName, prop.Value, prop.Source)

	}
	fmt.Printf("\n")

	for _, child := range d.Children {
		oldWalkDataset(&child)
	}
}

func listDatasets() {
	datasets, err := zfs.DatasetOpenAll()
	if err != nil {
		panic(err)
	}

	defer func() {
		for _, d := range datasets {
			d.Close()
		}
	}()

	// Pool() - returns attached Pool; no way to go the other direction?
	// GetProperty() , ReloadProperties()
	for _, d := range datasets {
		oldWalkDataset(&d)
	}
}

func walkVDevTreeNode(f func(*zfs.VDevTree) error, n *zfs.VDevTree) error {
	if err := f(n); err != nil {
		return err
	}

	for _, child := range n.Devices {
		if err := walkVDevTreeNode(f, &child); err != nil {
			return err
		}
	}
	return nil
}

func getDatasetsByName() (map[string]zfs.Dataset, error) {
	panic("don't use this function; it closes the handles it returns!")

	datasetsByName := make(map[string]zfs.Dataset)
	rootDatasets, err := zfs.DatasetOpenAll()
	if err != nil {
		panic(err)
	}
	defer func() {
		for _, d := range rootDatasets {
			d.Close()
		}
	}()
	for _, d := range rootDatasets {
		walkDataset(func(dd zfs.Dataset) error {
			if dd.Properties[zfs.DatasetPropType].Value == "snapshot" {
				return nil
			}
			path, err := dd.Path()
			if err != nil {
				return err
			}
			datasetsByName[path] = dd
			return nil
		}, d)
	}

	// for path, d := range datasetsByName {
	// 	fmt.Printf(" - %v\n", path)
	// 	_ = d
	// }

	return datasetsByName, nil
}

func walkVdevs() {
	pools, err := zfs.PoolOpenAll()
	if err != nil {
		panic(err)
	}

	defer func() {
		for _, p := range pools {
			p.Close()
		}
	}()

	for _, p := range pools {

		vdevTree, err := p.VDevTree()
		if err != nil {
			panic(err)
		}

		walkVDevTreeNode(func(n *zfs.VDevTree) error {
			// n.Type VDevType
			/*
				Parity   uint
				Path     string
				Name     string
				Stat     VDevStat
				ScanStat PoolScanStat
			*/
			fmt.Printf("%s\n", *n)
			return nil
		}, &vdevTree)

		// vdevTree, err := p.VDevTree()

		// name, err := p.Name()
		// if err != nil {
		// 	panic(err)
		// }

		// state, err := p.State()
		// if err != nil {
		// 	panic(err)
		// }

		// status, err := p.Status()
		// if err != nil {
		// 	panic(err)
		// }

		// fmt.Printf("%v\n  state: %v\n  status: %v\n\n", name, state, status)
	}

}
